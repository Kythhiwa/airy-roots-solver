#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <float.h>
#define ld long double



ld c2  = 0.526001519587677318785587544488E-01,
       c3  = 0.789002279381515978178381316732E-01,
       c4  = 0.118350341907227396726757197510E+00,
       c5  = 0.281649658092772603273242802490E+00,
       c6  = 0.333333333333333333333333333333E+00,
       c7  = 0.25E+00,
       c8  = 0.307692307692307692307692307692E+00,
       c9  = 0.651282051282051282051282051282E+00,
       c10 = 0.6E+00,
       c11 = 0.857142857142857142857142857142E+00;

ld b1 = 5.42937341165687622380535766363E-2L,
       b6 =   4.45031289275240888144113950566E0L,
       b7 =   1.89151789931450038304281599044E0L,
       b8 =  -5.8012039600105847814672114227E0L,
       b9 =   3.1116436695781989440891606237E-1L,
       b10 = -1.52160949662516078556178806805E-1L,
       b11 =  2.01365400804030348374776537501E-1L,
       b12 =  4.47106157277725905176885569043E-2L,


       a21 =    5.26001519587677318785587544488E-2L,
       a31 =    1.97250569845378994544595329183E-2L,
       a32 =    5.91751709536136983633785987549E-2L,
       a41 =    2.95875854768068491816892993775E-2L,
       a43 =    8.87627564304205475450678981324E-2L,
       a51 =    2.41365134159266685502369798665E-1L,
       a53 =   -8.84549479328286085344864962717E-1L,
       a54 =    9.24834003261792003115737966543E-1L,
       a61 =    3.7037037037037037037037037037E-2L,
       a64 =    1.70828608729473871279604482173E-1L,
       a65 =    1.25467687566822425016691814123E-1L,
       a71 =    3.7109375E-2L,
       a74 =    1.70252211019544039314978060272E-1L,
       a75 =    6.02165389804559606850219397283E-2L,
       a76 =   -1.7578125E-2L,

       a81 =    3.70920001185047927108779319836E-2L,
       a84 =    1.70383925712239993810214054705E-1L,
       a85 =    1.07262030446373284651809199168E-1L,
       a86 =   -1.53194377486244017527936158236E-2L,
       a87 =    8.27378916381402288758473766002E-3L,
       a91 =    6.24110958716075717114429577812E-1L,
       a94 =   -3.36089262944694129406857109825E0L,
       a95 =   -8.68219346841726006818189891453E-1L,
       a96 =    2.75920996994467083049415600797E1L,
       a97 =    2.01540675504778934086186788979E1L,
       a98 =   -4.34898841810699588477366255144E1L,
       a101 =   4.77662536438264365890433908527E-1L,
       a104 =  -2.48811461997166764192642586468E0L,
       a105 =  -5.90290826836842996371446475743E-1L,
       a106 =   2.12300514481811942347288949897E1L,
       a107 =   1.52792336328824235832596922938E1L,
       a108 =  -3.32882109689848629194453265587E1L,
       a109 =  -2.03312017085086261358222928593E-2L,

       a111 =  -9.3714243008598732571704021658E-1L,
       a114 =   5.18637242884406370830023853209E0L,
       a115 =   1.09143734899672957818500254654E0L,
       a116 =  -8.14978701074692612513997267357E0L,
       a117 =  -1.85200656599969598641566180701E1L,
       a118 =   2.27394870993505042818970056734E1L,
       a119 =   2.49360555267965238987089396762E0L,
       a1110 = -3.0467644718982195003823669022E0L,
       a121 =   2.27331014751653820792359768449E0L,
       a124 =  -1.05344954667372501984066689879E1L,
       a125 =  -2.00087205822486249909675718444E0L,
       a126 =  -1.79589318631187989172765950534E1L,
       a127 =   2.79488845294199600508499808837E1L,
       a128 =  -2.85899827713502369474065508674E0L,
       a129 =  -8.87285693353062954433549289258E0L,
       a1210 =  1.23605671757943030647266201528E1L,
       a1211 =  6.43392746015763530355970484046E-1L;


void f(ld x, ld y[2], ld dy[2]) {
    dy[0] = y[1];
    dy[1] = x * y[0];
}

void dopri8_step(ld* x, ld y[2], ld h) {
    ld k1[2], k2[2], k3[2], k4[2], k5[2], k6[2], k7[2], k8[2], k9[2], k10[2], k11[2], k12[2], k13[2];
    ld y_temp[2];
    //k1
    f(*x, y, k1);
    //k2
    y_temp[0] = y[0] + h * a21 * k1[0];
    y_temp[1] = y[1] + h * a21 * k1[1];
    f(*x + c2 * h, y_temp, k2);
    //k3 
    y_temp[0] = y[0] + h * (a31 * k1[0] + a32 * k2[0]);
    y_temp[1] = y[1] + h * (a31 * k1[1] + a32 * k2[1]);
    f(*x + c3 * h, y_temp, k3);
    //k4
    y_temp[0] = y[0] + h * (a41 * k1[0] + a43 * k3[0]);
    y_temp[1] = y[1] + h * (a41 * k1[1] + a43 * k3[1]);
    f(*x + c4 * h, y_temp, k4);
    //k5
    y_temp[0] = y[0] + h * (a51 * k1[0] + a53 * k3[0] + a54 * k4[0]);
    y_temp[1] = y[1] + h * (a51 * k1[1] + a53 * k3[1] + a54 * k4[1]);
    f(*x + c5 * h, y_temp, k5);
    //k6
    y_temp[0] = y[0] + h * (a61 * k1[0] + a64 * k4[0] + a65 * k5[0]);
    y_temp[1] = y[1] + h * (a61 * k1[1] + a64 * k4[1] + a65 * k5[1]);
    f(*x + c6 * h, y_temp, k6);
    //k7
    y_temp[0] = y[0] + h * (a71 * k1[0] + a74 * k4[0] + a75 * k5[0] + a76 * k6[0]);
    y_temp[1] = y[1] + h * (a71 * k1[1] + a74 * k4[1] + a75 * k5[1] + a76 * k6[1]);
    f(*x + c7 * h, y_temp, k7);
    //k8
    y_temp[0] = y[0] + h * (a81 * k1[0] + a84 * k4[0] + a85 * k5[0] + a86 * k6[0] + a87 * k7[0]);
    y_temp[1] = y[1] + h * (a81 * k1[1] + a84 * k4[1] + a85 * k5[1] + a86 * k6[1] + a87 * k7[1]);
    f(*x + c8 * h, y_temp, k8);
    //k9
    y_temp[0] = y[0] + h * (a91 * k1[0] + a94 * k4[0] + a95 * k5[0] + a96 * k6[0] + a97 * k7[0] + a98 * k8[0]);
    y_temp[1] = y[1] + h * (a91 * k1[1] + a94 * k4[1] + a95 * k5[1] + a96 * k6[1] + a97 * k7[1] + a98 * k8[1]);
    f(*x + c9 * h, y_temp, k9);
    //k10 
    y_temp[0] = y[0] + h * (a101 * k1[0] + a104 * k4[0] + a105 * k5[0] + a106 * k6[0] + a107 * k7[0] + a108 * k8[0] + a109 * k9[0]);
    y_temp[1] = y[1] + h * (a101 * k1[1] + a104 * k4[1] + a105 * k5[1] + a106 * k6[1] + a107 * k7[1] + a108 * k8[1] + a109 * k9[1]);
    f(*x + c10 * h, y_temp, k10);
    //k11
    y_temp[0] = y[0] + h * (a111 * k1[0] + a114 * k4[0] + a115 * k5[0] + a116 * k6[0] + a117 * k7[0] + a118 * k8[0] + a119 * k9[0] + a1110 * k10[0]);
    y_temp[1] = y[1] + h * (a111 * k1[1] + a114 * k4[1] + a115 * k5[1] + a116 * k6[1] + a117 * k7[1] + a118 * k8[1] + a119 * k9[1] + a1110 * k10[1]);
    f(*x + c11 * h, y_temp, k11);
    //k12 
    y_temp[0] = y[0] + h * (a121 * k1[0] + a124 * k4[0] + a125 * k5[0] + a126 * k6[0] + a127 * k7[0] + a128 * k8[0] + a129 * k9[0] + a1210 * k10[0] + a1211 * k11[0]);
    y_temp[1] = y[1] + h * (a121 * k1[1] + a124 * k4[1] + a125 * k5[1] + a126 * k6[1] + a127 * k7[1] + a128 * k8[1] + a129 * k9[1] + a1210 * k10[1] + a1211 * k11[1]);
    f(*x + h , y_temp, k12);

    y_temp[0] = b1 * k1[0] + b6 * k6[0] + b7 * k7[0] + b8 * k8[0] + b9 * k9[0] + b10 * k10[0] + b11 * k11[0] + b12 * k12[0];
    y_temp[1] = b1 * k1[1] + b6 * k6[1] + b7 * k7[1] + b8 * k8[1] + b9 * k9[1] + b10 * k10[1] + b11 * k11[1] + b12 * k12[1];
    y[0] = y[0] + h * y_temp[0];
    y[1] = y[1] + h * y_temp[1];
    *x += h;
}

void print_memory_binary(void *ptr, size_t size) {
    char* p = (char*) ptr;
    int n = FLT_MANT_DIG - 1;
    if (size == sizeof(double)) n = DBL_MANT_DIG - 1;
    if (size == sizeof(long double)) n = LDBL_MANT_DIG - 1;
    int bits[n];
    int t = n;
    for (int i = 0; i < size; i++) {
        for (int j = 0; j < 8; j++) {
            if (t < 0 ) break;
            bits[--t] = ( p[i] & (1 << j)) ? 1 : 0;
         }
    }
    for (int i = 0; i < n; i++) printf("%d", bits[i]);
    putchar('\n');
}

void comp(ld a, ld mid, ld y_mid[2]) {
    ld h = -fabsl(a - mid) / 10.0L;
    int i = 0;
   
    while ((h > 0 && a < mid) || (h < 0 && a > mid)) {
        if (i > 100) break;
        
        if ((h > 0 && a + h > mid) || (h < 0 && a + h < mid)) {
            h = mid - a;
        }
        
        dopri8_step(&a, y_mid, h);
        i++;
    }
}

ld bisection(ld a, ld b, ld y_a[2], ld y_b[2], int max_iter) {
    int i = 1;
    printf("\nМетод бисекции:\n");
    while (i <= max_iter) {
        ld mid = (a + b) / 2.0L;
        ld y_mid[2] = {y_a[0], y_a[1]};
        if (mid == a || mid == b) break;
        comp(a, mid, y_mid);
        
        printf("Итерация %2d: x = %.30Lf, f(x) = % .30Lf\n", i, mid, y_mid[0]);
        
        if (y_mid[0] * y_a[0] < 0) {
            b = mid;
            y_b[0] = y_mid[0];
            y_b[1] = y_mid[1];
        } else {
            a = mid;
            y_a[0] = y_mid[0];
            y_a[1] = y_mid[1];
        }
        i++;
    }
    return a;
}

int main() {
    ld x = 0.0L;
    ld y[2] = {
        0.35502805388781723926006318600418317639797917419917724058332651030081004245L,
        -0.2588194037928067984051835601892039634790911383549345822100018138561027726L
    };
    
    ld e[8] = {
        -2.33810741045976703848919725244673544064,
        -4.08794944413097061663698870145739106022476469910853,
        -5.52055982809555105912985551293129357379721428061753,
        -6.78670809007175899878024638449617696605388247739349,
        -7.94413358712085312313828055579826853214067439697221,
        -9.02265085334098038015819083988008925652467753515608,
        -10.0401743415580859305945567373625180940429025691058, 
        -11.0085243037332628932354396495901510167308253815040
    };
    
    const int max_roots = 8;
    const int max_bisect_iter = 60;
    ld* x_comp = (ld*)calloc(max_roots, sizeof(ld));
    ld h = -1e-3L;
    ld x_end = -20.0L;
    int root_count = 0;
    
    printf("Поиск корней функции Эйри Ai(x) на интервале [%.2Lf, %.2Lf]\n", x_end, 0.0L);
    
    while (x > x_end && root_count < max_roots) {
        ld x_prev = x;
        ld y_prev[2] = {y[0], y[1]};
        
        dopri8_step(&x, y, h);
        
        if (y[0] * y_prev[0] <= 0) {
            ld cur_a[2] = {y_prev[0], y_prev[1]};
            ld cur_b[2] = {y_prev[0], y_prev[1]};
            
            ld r = bisection(x_prev, x, cur_a, cur_b, max_bisect_iter);
            printf("Найден корень %d: x = %.30Lf, f(x) = %.15Le\n", 
                  root_count+1, r, cur_a[0]);
                  
            x_comp[root_count] = r;
            root_count++;
        }
    }
    
    printf("\nСравнение с эталонными значениями:\n");
    for (int i = 0; i < root_count; i++) {
        printf("Корень %d:\n", i+1);
        printf("Вычислено: %.40Lf\n", x_comp[i]);
        printf("Эталон:    %.40Lf\n", e[i]);
        printf("Разность:  %.40Lf\n", e[i] - x_comp[i]);
        printf("Разность:  %.10Le\n", e[i] - x_comp[i]);
        print_memory_binary(&x_comp[i], sizeof(x_comp[i]));
        print_memory_binary(&e[i], sizeof(e[i]));
        printf("\n");
    }
    
    free(x_comp);
    return 0;
}
